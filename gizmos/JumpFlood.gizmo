#! C:/Program Files/Nuke16.0v1/nuke-16.0.1.dll -nx
version 16.0 v1
Group {
 name JumpFlood
 disable_group_view true
 updateUI "tn = nuke.thisNode()\n\nmin_steps = int(tn.knob('min_steps').value())\nmax_steps = int(tn.knob('max_steps').value())\n\ninput_steps = int(tn.knobs()\[\"steps\"].value())\ntext = \"<br>SEARCH RADIUS: <b>\[searchradius] px</b> \[warning]<br>\"\n\nif input_steps > max_steps:\n    text = text.replace(\"\[warning]\", f\"<font color='#d6491a'>(max \{max_steps\} steps)</font>\")\n    text = text.replace(\"\[searchradius] px\", \"<font color='#d6491a'>\[searchradius] px</font>\")\n    steps = max_steps\nelif input_steps < min_steps:\n    text = text.replace(\"\[warning]\", f\"<font color='#d6491a'>(min \{min_steps\} step)</font>\")\n    text = text.replace(\"\[searchradius] px\", \"<font color='#d6491a'>\[searchradius] px</font>\")\n    steps = min_steps\nelse:\n    text = text.replace(\"\[warning]\", \"\")\n    steps = input_steps\n    \nradiusInPx = pow(2, steps)\n\ntext = text.replace(\"\[searchradius]\", str(radiusInPx))\n\ntn.knobs()\[\"txt_stepinfo\"].setValue(text)"
 tile_color 0x55bfffff
 addUserKnob {20 tab_JumpFlood l JumpFlood}
 addUserKnob {3 steps l Steps t "Amount of steps of the Jump Flood Algorithm to perform.\n\nEach pixel will look for neighbors in a radius of 2^(steps).\nAs an example, 11 steps = 2^11 = 2048px.\n\nMIN: 1, MAX: 20"}
 steps 8
 addUserKnob {22 btn_reformat l "Fill Format" t "Sets the steps to the value required to cover the entire format." -STARTLINE T "tn = nuke.thisNode()\n\ndef ceil_log2(n):\n    r = 0\n    n -= 1  # Subtract 1 to handle the case when n is already a power of 2\n    while n > 0:\n        r += 1\n        n //= 2  # Use integer division to shift right by one bit\n    return r\n\nwidth = tn.format().width()\nheight = tn.format().height()\n\nmax_dim = max(width, height)\niterations = ceil_log2(max_dim)\n\niterations = max(min(iterations,18),1)\n\ntn.knobs()\[\"steps\"].setValue(iterations)\n\n"}
 addUserKnob {7 thresh l Threshold t "The alpha will need to be equal to or higher than this value in order to be considered as actually being part of the alpha."}
 thresh 0.5
 addUserKnob {6 invert l Invert t "Inverts the alpha" -STARTLINE}
 addUserKnob {7 distdiv l "Divide Distance" t "Divides the distance field (alpha) by this value, so it will range from 0 to this value. It will still go above this. Helps you actually be able to see the distance field in effect." R 1 512}
 distdiv 1
 addUserKnob {6 autodiv l Auto-divide t "Automatically divide by the search radius.\nThis is not limited by the image bounds nor does it account for diagonals, so it's not a true normalization to a 0:1 range." -STARTLINE}
 autodiv true
 addUserKnob {26 divider l "" +STARTLINE}
 addUserKnob {26 txt_stepinfo l "" +STARTLINE T "<br>SEARCH RADIUS: <b>256 px</b> <br>"}
 addUserKnob {3 min_steps +INVISIBLE}
 min_steps 1
 addUserKnob {3 max_steps +INVISIBLE}
 max_steps 20
 addUserKnob {6 test_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 Info}
 addUserKnob {26 infotext l "" +STARTLINE T "<font size=\"6\" color=\"#55BFFF\"><b>JumpFlood</b></font><br>\n<i>v1.1.0</i><br>\n<i>Pelle Nordentoft</i>\n\n<br><br><br>\n\n\nPerforms the Jump Flood Algorithm on the alpha<br>\nchannel of the image, based on a threshold.<br>\nThis results in a distance field from every pixel<br>\nto the closest edge of the alpha.\n<br>\n<br>\n<font color=\"#666666\">\nr: x of closest pixel<br>\ng: y of closest pixel<br>\nb: thresholded alpha<br>\na: distance to closest pixel (not normalized)<br>\n</font>\n\n<br>\n\nA part of the Visual Magic toolkit."}
}
 Input {
  inputs 0
  name Input
  xpos -297
  ypos -158
 }
 Expression {
  temp_name0 invval
  temp_expr0 "parent.invert ? 0 : 1"
  temp_name1 val
  temp_expr1 parent.invert
  expr3 "a >= parent.thresh ? invval : val"
  name Thresholding
  xpos -297
  ypos -112
 }
 Dot {
  name Dot2
  xpos -263
  ypos -62
 }
set N96479000 [stack 0]
 Dot {
  name Dot3
  xpos -373
  ypos -62
 }
 Dot {
  name Dot1
  xpos -373
  ypos 228
 }
push $N96479000
 Expression {
  expr0 x
  expr1 y
  expr2 a
  expr3 "a > 0 ? 1 : 0"
  name JumpFlood_Init
  xpos -297
  ypos -23
 }
 BlinkScript {
  isBaked true
  recompileCount 39
  ProgramGroup 1
  KernelDescription "3 \"JumpFloodStepKernel\" iterate pixelWise 58b60226ad073768aa269ed3391f8cbcd1507b8b276d5e17d1c8ce660b5dc612 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel JumpFloodStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  "JumpFloodStepKernel_Max Iterations" {{max(parent.steps,1)}}
  rebuild_finalise ""
  name JumpFloodStep_Kernel
  xpos -297
  ypos 32
 }
 BlinkScript {
  isBaked true
  recompileCount 38
  KernelDescription "3 \"JumpFloodStepKernel\" iterate pixelWise 58b60226ad073768aa269ed3391f8cbcd1507b8b276d5e17d1c8ce660b5dc612 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel JumpFloodStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  JumpFloodStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "JumpFloodStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name JumpFloodStep_Kernel_1
  xpos -167
  ypos 32
  disable {{"JumpFloodStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 38
  KernelDescription "3 \"JumpFloodStepKernel\" iterate pixelWise 58b60226ad073768aa269ed3391f8cbcd1507b8b276d5e17d1c8ce660b5dc612 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel JumpFloodStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  JumpFloodStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "JumpFloodStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name JumpFloodStep_Kernel_2
  xpos -31
  ypos 32
  disable {{"JumpFloodStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 38
  KernelDescription "3 \"JumpFloodStepKernel\" iterate pixelWise 58b60226ad073768aa269ed3391f8cbcd1507b8b276d5e17d1c8ce660b5dc612 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel JumpFloodStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  JumpFloodStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "JumpFloodStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name JumpFloodStep_Kernel_3
  xpos 108
  ypos 32
  disable {{"JumpFloodStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 38
  KernelDescription "3 \"JumpFloodStepKernel\" iterate pixelWise 58b60226ad073768aa269ed3391f8cbcd1507b8b276d5e17d1c8ce660b5dc612 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel JumpFloodStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  JumpFloodStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "JumpFloodStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name JumpFloodStep_Kernel_4
  xpos 244
  ypos 32
  disable {{"JumpFloodStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 38
  KernelDescription "3 \"JumpFloodStepKernel\" iterate pixelWise 58b60226ad073768aa269ed3391f8cbcd1507b8b276d5e17d1c8ce660b5dc612 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel JumpFloodStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  JumpFloodStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "JumpFloodStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name JumpFloodStep_Kernel_5
  xpos 384
  ypos 32
  disable {{"JumpFloodStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 38
  KernelDescription "3 \"JumpFloodStepKernel\" iterate pixelWise 58b60226ad073768aa269ed3391f8cbcd1507b8b276d5e17d1c8ce660b5dc612 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel JumpFloodStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  JumpFloodStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "JumpFloodStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name JumpFloodStep_Kernel_6
  xpos 520
  ypos 32
  disable {{"JumpFloodStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 38
  KernelDescription "3 \"JumpFloodStepKernel\" iterate pixelWise 58b60226ad073768aa269ed3391f8cbcd1507b8b276d5e17d1c8ce660b5dc612 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel JumpFloodStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  JumpFloodStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "JumpFloodStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name JumpFloodStep_Kernel_7
  xpos 659
  ypos 32
  disable {{"JumpFloodStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 38
  KernelDescription "3 \"JumpFloodStepKernel\" iterate pixelWise 58b60226ad073768aa269ed3391f8cbcd1507b8b276d5e17d1c8ce660b5dc612 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel JumpFloodStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  JumpFloodStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "JumpFloodStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name JumpFloodStep_Kernel_8
  xpos 795
  ypos 32
  disable {{"JumpFloodStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 38
  KernelDescription "3 \"JumpFloodStepKernel\" iterate pixelWise 58b60226ad073768aa269ed3391f8cbcd1507b8b276d5e17d1c8ce660b5dc612 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel JumpFloodStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  JumpFloodStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "JumpFloodStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name JumpFloodStep_Kernel_9
  xpos 933
  ypos 32
  disable {{"JumpFloodStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 38
  KernelDescription "3 \"JumpFloodStepKernel\" iterate pixelWise 58b60226ad073768aa269ed3391f8cbcd1507b8b276d5e17d1c8ce660b5dc612 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel JumpFloodStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  JumpFloodStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "JumpFloodStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name JumpFloodStep_Kernel_10
  xpos 1069
  ypos 32
  disable {{"JumpFloodStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 38
  KernelDescription "3 \"JumpFloodStepKernel\" iterate pixelWise 58b60226ad073768aa269ed3391f8cbcd1507b8b276d5e17d1c8ce660b5dc612 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel JumpFloodStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  JumpFloodStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "JumpFloodStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name JumpFloodStep_Kernel_11
  xpos 1208
  ypos 32
  disable {{"JumpFloodStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 38
  KernelDescription "3 \"JumpFloodStepKernel\" iterate pixelWise 58b60226ad073768aa269ed3391f8cbcd1507b8b276d5e17d1c8ce660b5dc612 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel JumpFloodStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  JumpFloodStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "JumpFloodStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name JumpFloodStep_Kernel_12
  xpos 1344
  ypos 32
  disable {{"JumpFloodStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 38
  KernelDescription "3 \"JumpFloodStepKernel\" iterate pixelWise 58b60226ad073768aa269ed3391f8cbcd1507b8b276d5e17d1c8ce660b5dc612 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel JumpFloodStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  JumpFloodStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "JumpFloodStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name JumpFloodStep_Kernel_13
  xpos 1484
  ypos 32
  disable {{"JumpFloodStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 38
  KernelDescription "3 \"JumpFloodStepKernel\" iterate pixelWise 58b60226ad073768aa269ed3391f8cbcd1507b8b276d5e17d1c8ce660b5dc612 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel JumpFloodStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  JumpFloodStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "JumpFloodStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name JumpFloodStep_Kernel_14
  xpos 1620
  ypos 32
  disable {{"JumpFloodStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 38
  KernelDescription "3 \"JumpFloodStepKernel\" iterate pixelWise 58b60226ad073768aa269ed3391f8cbcd1507b8b276d5e17d1c8ce660b5dc612 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel JumpFloodStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  JumpFloodStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "JumpFloodStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name JumpFloodStep_Kernel_15
  xpos 1759
  ypos 32
  disable {{"JumpFloodStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 38
  KernelDescription "3 \"JumpFloodStepKernel\" iterate pixelWise 58b60226ad073768aa269ed3391f8cbcd1507b8b276d5e17d1c8ce660b5dc612 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel JumpFloodStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  JumpFloodStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "JumpFloodStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name JumpFloodStep_Kernel_16
  xpos 1895
  ypos 32
  disable {{"JumpFloodStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 38
  KernelDescription "3 \"JumpFloodStepKernel\" iterate pixelWise 58b60226ad073768aa269ed3391f8cbcd1507b8b276d5e17d1c8ce660b5dc612 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel JumpFloodStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  JumpFloodStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "JumpFloodStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name JumpFloodStep_Kernel_17
  xpos 2037
  ypos 32
  disable {{"JumpFloodStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 38
  KernelDescription "3 \"JumpFloodStepKernel\" iterate pixelWise 58b60226ad073768aa269ed3391f8cbcd1507b8b276d5e17d1c8ce660b5dc612 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel JumpFloodStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  JumpFloodStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "JumpFloodStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name JumpFloodStep_Kernel_18
  xpos 2176
  ypos 32
  disable {{"JumpFloodStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 38
  KernelDescription "3 \"JumpFloodStepKernel\" iterate pixelWise 58b60226ad073768aa269ed3391f8cbcd1507b8b276d5e17d1c8ce660b5dc612 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel JumpFloodStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  JumpFloodStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "JumpFloodStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name JumpFloodStep_Kernel_19
  xpos 2312
  ypos 32
  disable {{"JumpFloodStepKernel_Iteration > steps"}}
 }
 Dot {
  name Dot5
  xpos 2346
  ypos 101
 }
 Dot {
  name Dot4
  xpos -263
  ypos 101
 }
 BlinkScript {
  isBaked true
  recompileCount 19
  KernelDescription "3 \"JumpFloodFinalizeKernel\" iterate pixelWise 64d092d216a2205f81157dbc1f9340ee8c79c463f765583df392b0d2206e2bcd 2 \"src\" Read Point \"dst\" Write Point 0 0 0"
  kernelSource "kernel JumpFloodFinalizeKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessPoint, eEdgeClamped> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n  \n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n        \n        float distance = sqrt(pow((src().x-pos.x),2)+pow((src().y-pos.y),2));\n        \n        float4 result;\n        \n        // Alpha is defined state, rgb are distance, undefined pixels have 0 distance\n        if (src().w>0) \{\n            result = float4(src().x,src().y,0,distance);\n        \} else \{\n            result = 0;\n        \}\n        \n        dst() = result;\n    \}\n\};"
  rebuild ""
  rebuild_finalise ""
  name JumpFloodFinalize_Kernel
  xpos -297
  ypos 148
 }
 Copy {
  inputs 2
  from0 rgba.alpha
  to0 rgba.blue
  bbox B
  name CopyThreshAlpha
  xpos -297
  ypos 218
 }
 Grade {
  channels alpha
  whitepoint {{"parent.autodiv ? pow(2,parent.steps) : parent.distdiv"}}
  name WhitepointDivision
  xpos -297
  ypos 280
 }
 Output {
  name Output
  xpos -297
  ypos 343
 }
end_group
