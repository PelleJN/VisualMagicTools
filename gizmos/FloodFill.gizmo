#! C:/Program Files/Nuke16.0v1/nuke-16.0.1.dll -nx
version 16.0 v1
Group {
 name FloodFill_AlphaDistance
 updateUI floodFillUiUpdate()
 tile_color 0x55bfffff
 disable_group_view true
 addUserKnob {20 tab_FloodFill l FloodFill}
 addUserKnob {3 steps l Steps t "Amount of steps of the Flood Fill algorithm to perform.\n\nEach pixel will look for neighbors in a radius of 2^(steps).\nAs an example, 11 steps = 2^11 = 2048px.\n\nMIN: 1, MAX: 20"}
 steps 8
 addUserKnob {22 btn_reformat l "Fill Format" t "Sets the steps to the value required to cover the entire format." -STARTLINE T "tn = nuke.thisNode()\n\ndef ceil_log2(n):\n    r = 0\n    n -= 1  # Subtract 1 to handle the case when n is already a power of 2\n    while n > 0:\n        r += 1\n        n //= 2  # Use integer division to shift right by one bit\n    return r\n\nwidth = tn.format().width()\nheight = tn.format().height()\n\nmax_dim = max(width, height)\niterations = ceil_log2(max_dim)\n\niterations = max(min(iterations,18),1)\n\ntn.knobs()\[\"steps\"].setValue(iterations)\n\n"}
 addUserKnob {7 thresh l Threshold t "The alpha will need to be equal to or higher than this value in order to be considered as actually being part of the alpha."}
 thresh 0.5
 addUserKnob {6 invert l Invert t "Inverts the alpha" -STARTLINE}
 addUserKnob {7 distdiv l "Divide Distance" t "Divides the distance field (alpha) by this value, so it will range from 0 to this value. It will still go above this. Helps you actually be able to see the distance field in effect." R 1 512}
 distdiv 1
 addUserKnob {6 autodiv l Auto-divide t "Automatically divide by the search radius.\nThis is not limited by the image bounds nor does it account for diagonals, so it's not a true normalization to a 0:1 range." -STARTLINE}
 autodiv true
 addUserKnob {26 divider l "" +STARTLINE}
 addUserKnob {26 txt_stepinfo l "" +STARTLINE T "<br>SEARCH RADIUS: <b>256 px</b> <br>"}
 addUserKnob {3 min_steps +INVISIBLE}
 min_steps 1
 addUserKnob {3 max_steps +INVISIBLE}
 max_steps 20
 addUserKnob {6 test_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 Info}
 addUserKnob {26 infotext l "" +STARTLINE T "<font size=\"6\" color=\"#55BFFF\"><b>FloodFill</b></font><br>\n<i>v1.0.0</i><br>\n<i>Pelle Nordentoft</i>\n\n<br><br><br>\n\n\nPerforms the Flood Fill algorithm on the alpha<br>\nchannel of the image, based on a threshold.<br>\nThis results in a distance field from every pixel<br>\nto the closest edge of the alpha.\n<br>\n<br>\n<font color=\"#666666\">\nr: x of closest pixel<br>\ng: y of closest pixel<br>\nb: thresholded alpha<br>\na: distance to closest pixel (not normalized)<br>\n</font>\n\n<br>\n\nA part of the Visual Magic toolkit."}
}
 Input {
  inputs 0
  name Input
  xpos -297
  ypos -158
 }
 Expression {
  temp_name0 invval
  temp_expr0 "parent.invert ? 0 : 1"
  temp_name1 val
  temp_expr1 parent.invert
  expr3 "a >= parent.thresh ? invval : val"
  name Thresholding
  xpos -297
  ypos -112
 }
 Dot {
  name Dot2
  xpos -263
  ypos -62
 }
set N7ad4400 [stack 0]
 Dot {
  name Dot3
  xpos -373
  ypos -62
 }
 Dot {
  name Dot1
  xpos -373
  ypos 228
 }
push $N7ad4400
 Expression {
  expr0 x
  expr1 y
  expr2 a
  expr3 "a > 0 ? 1 : 0"
  name FloodFill_Init
  xpos -297
  ypos -23
 }
 BlinkScript {
  isBaked true
  recompileCount 37
  ProgramGroup 1
  KernelDescription "3 \"FloodFillStepKernel\" iterate pixelWise 898da5c2894c8f8697e9436f19683496dcb70eae67ccb234a16ed32845f73dd0 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel FloodFillStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  "FloodFillStepKernel_Max Iterations" {{max(parent.steps,1)}}
  rebuild_finalise ""
  name FloodFillStep_Kernel
  xpos -297
  ypos 32
 }
 BlinkScript {
  isBaked true
  recompileCount 37
  ProgramGroup 1
  KernelDescription "3 \"FloodFillStepKernel\" iterate pixelWise 898da5c2894c8f8697e9436f19683496dcb70eae67ccb234a16ed32845f73dd0 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel FloodFillStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  FloodFillStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "FloodFillStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name FloodFillStep_Kernel_1
  xpos -152
  ypos 32
  disable {{"FloodFillStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 37
  ProgramGroup 1
  KernelDescription "3 \"FloodFillStepKernel\" iterate pixelWise 898da5c2894c8f8697e9436f19683496dcb70eae67ccb234a16ed32845f73dd0 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel FloodFillStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  FloodFillStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "FloodFillStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name FloodFillStep_Kernel_2
  xpos -20
  ypos 32
  disable {{"FloodFillStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 37
  ProgramGroup 1
  KernelDescription "3 \"FloodFillStepKernel\" iterate pixelWise 898da5c2894c8f8697e9436f19683496dcb70eae67ccb234a16ed32845f73dd0 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel FloodFillStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  FloodFillStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "FloodFillStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name FloodFillStep_Kernel_3
  xpos 113
  ypos 32
  disable {{"FloodFillStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 37
  ProgramGroup 1
  KernelDescription "3 \"FloodFillStepKernel\" iterate pixelWise 898da5c2894c8f8697e9436f19683496dcb70eae67ccb234a16ed32845f73dd0 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel FloodFillStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  FloodFillStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "FloodFillStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name FloodFillStep_Kernel_4
  xpos 245
  ypos 32
  disable {{"FloodFillStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 37
  ProgramGroup 1
  KernelDescription "3 \"FloodFillStepKernel\" iterate pixelWise 898da5c2894c8f8697e9436f19683496dcb70eae67ccb234a16ed32845f73dd0 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel FloodFillStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  FloodFillStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "FloodFillStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name FloodFillStep_Kernel_5
  xpos 379
  ypos 32
  disable {{"FloodFillStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 37
  ProgramGroup 1
  KernelDescription "3 \"FloodFillStepKernel\" iterate pixelWise 898da5c2894c8f8697e9436f19683496dcb70eae67ccb234a16ed32845f73dd0 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel FloodFillStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  FloodFillStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "FloodFillStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name FloodFillStep_Kernel_6
  xpos 511
  ypos 32
  disable {{"FloodFillStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 37
  ProgramGroup 1
  KernelDescription "3 \"FloodFillStepKernel\" iterate pixelWise 898da5c2894c8f8697e9436f19683496dcb70eae67ccb234a16ed32845f73dd0 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel FloodFillStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  FloodFillStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "FloodFillStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name FloodFillStep_Kernel_7
  xpos 644
  ypos 32
  disable {{"FloodFillStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 37
  ProgramGroup 1
  KernelDescription "3 \"FloodFillStepKernel\" iterate pixelWise 898da5c2894c8f8697e9436f19683496dcb70eae67ccb234a16ed32845f73dd0 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel FloodFillStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  FloodFillStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "FloodFillStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name FloodFillStep_Kernel_8
  xpos 776
  ypos 32
  disable {{"FloodFillStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 37
  ProgramGroup 1
  KernelDescription "3 \"FloodFillStepKernel\" iterate pixelWise 898da5c2894c8f8697e9436f19683496dcb70eae67ccb234a16ed32845f73dd0 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel FloodFillStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  FloodFillStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "FloodFillStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name FloodFillStep_Kernel_9
  xpos 912
  ypos 32
  disable {{"FloodFillStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 37
  ProgramGroup 1
  KernelDescription "3 \"FloodFillStepKernel\" iterate pixelWise 898da5c2894c8f8697e9436f19683496dcb70eae67ccb234a16ed32845f73dd0 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel FloodFillStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  FloodFillStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "FloodFillStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name FloodFillStep_Kernel_10
  xpos 1044
  ypos 32
  disable {{"FloodFillStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 37
  ProgramGroup 1
  KernelDescription "3 \"FloodFillStepKernel\" iterate pixelWise 898da5c2894c8f8697e9436f19683496dcb70eae67ccb234a16ed32845f73dd0 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel FloodFillStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  FloodFillStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "FloodFillStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name FloodFillStep_Kernel_11
  xpos 1177
  ypos 32
  disable {{"FloodFillStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 37
  ProgramGroup 1
  KernelDescription "3 \"FloodFillStepKernel\" iterate pixelWise 898da5c2894c8f8697e9436f19683496dcb70eae67ccb234a16ed32845f73dd0 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel FloodFillStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  FloodFillStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "FloodFillStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name FloodFillStep_Kernel_12
  xpos 1309
  ypos 32
  disable {{"FloodFillStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 37
  ProgramGroup 1
  KernelDescription "3 \"FloodFillStepKernel\" iterate pixelWise 898da5c2894c8f8697e9436f19683496dcb70eae67ccb234a16ed32845f73dd0 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel FloodFillStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  FloodFillStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "FloodFillStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name FloodFillStep_Kernel_13
  xpos 1443
  ypos 32
  disable {{"FloodFillStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 37
  ProgramGroup 1
  KernelDescription "3 \"FloodFillStepKernel\" iterate pixelWise 898da5c2894c8f8697e9436f19683496dcb70eae67ccb234a16ed32845f73dd0 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel FloodFillStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  FloodFillStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "FloodFillStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name FloodFillStep_Kernel_14
  xpos 1575
  ypos 32
  disable {{"FloodFillStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 37
  ProgramGroup 1
  KernelDescription "3 \"FloodFillStepKernel\" iterate pixelWise 898da5c2894c8f8697e9436f19683496dcb70eae67ccb234a16ed32845f73dd0 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel FloodFillStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  FloodFillStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "FloodFillStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name FloodFillStep_Kernel_15
  xpos 1708
  ypos 32
  disable {{"FloodFillStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 37
  ProgramGroup 1
  KernelDescription "3 \"FloodFillStepKernel\" iterate pixelWise 898da5c2894c8f8697e9436f19683496dcb70eae67ccb234a16ed32845f73dd0 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel FloodFillStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  FloodFillStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "FloodFillStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name FloodFillStep_Kernel_16
  xpos 1840
  ypos 32
  disable {{"FloodFillStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 37
  ProgramGroup 1
  KernelDescription "3 \"FloodFillStepKernel\" iterate pixelWise 898da5c2894c8f8697e9436f19683496dcb70eae67ccb234a16ed32845f73dd0 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel FloodFillStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  FloodFillStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "FloodFillStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name FloodFillStep_Kernel_17
  xpos 1980
  ypos 32
  disable {{"FloodFillStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 37
  ProgramGroup 1
  KernelDescription "3 \"FloodFillStepKernel\" iterate pixelWise 898da5c2894c8f8697e9436f19683496dcb70eae67ccb234a16ed32845f73dd0 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel FloodFillStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  FloodFillStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "FloodFillStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name FloodFillStep_Kernel_18
  xpos 2113
  ypos 32
  disable {{"FloodFillStepKernel_Iteration > steps"}}
 }
 BlinkScript {
  isBaked true
  recompileCount 37
  ProgramGroup 1
  KernelDescription "3 \"FloodFillStepKernel\" iterate pixelWise 898da5c2894c8f8697e9436f19683496dcb70eae67ccb234a16ed32845f73dd0 2 \"src\" Read Ranged2D \"dst\" Write Point 2 \"Iteration\" Int 1 AQAAAA== \"Max Iterations\" Int 1 BAAAAA== 2 \"iteration\" 1 1 Default \"maxIterations\" 1 1 Default 3 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"srcconstEdgeColor\" Float 4 1 AAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel FloodFillStepKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessRanged2D, eEdgeConstant> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n    int iteration;\n    int maxIterations;\n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n        defineParam(iteration, \"Iteration\", 1);\n        defineParam(maxIterations, \"Max Iterations\", 4);\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n        int stepSize = pow(2,maxIterations-iteration);\n        src.setRange(-stepSize, -stepSize, stepSize, stepSize);\n        \n        // Macro to update the minimum distance and result.\n        // DIST is the computed distance, DIR is the values of the pixel in the given direction in a float4\n        #define UPDATE_MIN(DIST, DIR)         \\\n                if ((DIR).w > 0) \{            \\\n                    if ((DIST) < minDist) \{   \\\n                        minDist = (DIST);     \\\n                        result = (DIR);       \\\n                    \}                         \\\n                \}\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n    \n        int stepSize = pow(2,maxIterations-iteration); \n        \n        float4 nw = src(-stepSize, stepSize);\n        float4 nn = src(0, stepSize);\n        float4 ne = src(stepSize, stepSize);\n        float4 ee = src(stepSize, 0);\n        float4 se = src(stepSize, -stepSize);\n        float4 ss = src(0, -stepSize);\n        float4 sw = src(-stepSize, -stepSize);\n        float4 ww = src(-stepSize, 0);\n        \n        // Distance to pixel's north-western step\n        float nw_dist = sqrt(pow((nw.x-pos.x),2)+pow((nw.y-pos.y),2));\n        float nn_dist = sqrt(pow((nn.x-pos.x),2)+pow((nn.y-pos.y),2));\n        float ne_dist = sqrt(pow((ne.x-pos.x),2)+pow((ne.y-pos.y),2));\n        float ee_dist = sqrt(pow((ee.x-pos.x),2)+pow((ee.y-pos.y),2));\n        float se_dist = sqrt(pow((se.x-pos.x),2)+pow((se.y-pos.y),2));\n        float ss_dist = sqrt(pow((ss.x-pos.x),2)+pow((ss.y-pos.y),2));\n        float sw_dist = sqrt(pow((sw.x-pos.x),2)+pow((sw.y-pos.y),2));\n        float ww_dist = sqrt(pow((ww.x-pos.x),2)+pow((ww.y-pos.y),2));\n        \n        float minDist = 9999999;\n        float4 result = src(0,0);\n\n        // If the current pixel is initialized (has an alpha of 1) we need to take it into account for the distance check. Don't need to update \"result\" since it's already set to be the current pixel by default.\n        if (src(0,0).w > 0) \{\n            minDist = sqrt(pow((result.x-pos.x),2)+pow((result.y-pos.y),2)); // We're re-using the src (current) pixel from the \"result\" variable instead of sampling it again, should work.\n        \}\n        \n        UPDATE_MIN(nw_dist, nw);\n        UPDATE_MIN(nn_dist, nn);\n        UPDATE_MIN(ne_dist, ne);\n        UPDATE_MIN(ee_dist, ee);\n        UPDATE_MIN(se_dist, se);\n        UPDATE_MIN(ss_dist, ss);\n        UPDATE_MIN(sw_dist, sw);\n        UPDATE_MIN(ww_dist, ww);\n        \n        dst() = result;\n    \};\n\};"
  rebuild ""
  FloodFillStepKernel_Iteration {{"\[python \{int(nuke.thisNode().name().split('_')\[-1])+1\}]"}}
  "FloodFillStepKernel_Max Iterations" {{max(min(parent.steps,parent.max_steps),parent.min_steps)}}
  rebuild_finalise ""
  name FloodFillStep_Kernel_19
  xpos 2245
  ypos 32
  disable {{"FloodFillStepKernel_Iteration > steps"}}
 }
 Dot {
  name Dot5
  xpos 2279
  ypos 101
 }
 Dot {
  name Dot4
  xpos -263
  ypos 101
 }
 BlinkScript {
  isBaked true
  recompileCount 18
  ProgramGroup 1
  KernelDescription "3 \"FloodFillFinalizeKernel\" iterate pixelWise 7470581a6597c4aefe410e79f9a046f835fa457070d61bd7f0cce3b74f8a2c06 2 \"src\" Read Point \"dst\" Write Point 0 0 0"
  kernelSource "kernel FloodFillFinalizeKernel : ImageComputationKernel<ePixelWise> \{\n    // Input and output images\n    Image<eRead, eAccessPoint, eEdgeClamped> src;\n    Image<eWrite, eAccessPoint> dst;\n\n// Parameters are made available to the user as knobs.\nparam:\n  \n\n// Local variables can be initialised once in init() and used from all pixel positions.\nlocal:\n\n\n    // In define(), parameters can be given labels and default values.\n    void define() \{\n    \n    \}\n\n    // The init() function is run once before any calls to process().\n    void init() \{\n    \n    \}\n\n    // The process() function runs over all pixel positions of the output image.\n    void process(int2 pos) \{\n        \n        float distance = sqrt(pow((src().x-pos.x),2)+pow((src().y-pos.y),2));\n        \n        float4 result;\n        \n        // Alpha is defined state, rgb are distance, undefined pixels have 0 distance\n        if (src().w>0) \{\n            result = float4(src().x,src().y,0,distance);\n        \} else \{\n            result = 0;\n        \}\n        \n        dst() = result;\n    \}\n\};"
  rebuild ""
  rebuild_finalise ""
  name FloodFillFinalize_Kernel
  xpos -297
  ypos 155
 }
 Copy {
  inputs 2
  from0 rgba.alpha
  to0 rgba.blue
  bbox B
  name CopyThreshAlpha
  xpos -297
  ypos 218
 }
 Grade {
  channels alpha
  whitepoint {{"parent.autodiv ? pow(2,parent.steps) : parent.distdiv"}}
  name WhitepointDivision
  xpos -297
  ypos 280
 }
 Output {
  name Output
  xpos -297
  ypos 343
 }
end_group
